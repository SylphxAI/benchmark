# Reactive Async Operations

**‚ö†Ô∏è Feature Completeness Test**

This benchmarks tests **reactive async** capabilities - where async computations automatically recompute when their dependencies change. This is an advanced feature that only modern state management libraries support.

## Library Support Status

| Library | Reactive Async Support | Notes |
|---------|----------------------|--------|
| ‚úÖ **Jotai** | Native async atoms | Automatic dependency tracking and recomputation |
| ‚ùå Zustand | Not Supported | Manual async handling only |
| ‚ùå Redux Toolkit | Not Supported | RTK Query is separate, not reactive atoms |
| ‚ùå MobX | Not Supported | Has `flow` but not reactive async |
| ‚ùå Valtio | Not Supported | Proxy-based, no async support |
| ‚ùå Preact Signals | Not Supported | No async signals |
| ‚ùå Solid Signals | Not Supported | createResource is framework-level, not core |
| ‚ùå Zen | Not Supported | karma is async task runner, not reactive |

> **What is Reactive Async?**
>
> Reactive async means the library can:
> 1. Track dependencies inside async computations (like computed values)
> 2. Automatically invalidate async results when dependencies change
> 3. Re-run async computations on next read (lazy) or immediately (eager)
>
> This is crucial for modern applications with complex async state flows.

---

## Performance Benchmarks (Jotai Only)

### Reactive Async Read

**Performance:**

```
ü•á   Jotai              ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà       876.66 ops/sec
```

| Rank | Library | Ops/sec | Variance | Mean | p99 | Samples |
|------|---------|---------|----------|------|-----|----------|
| ü•á | **Jotai** | 876.66 | ¬±1.60% | 1.1407ms | 1.2552ms | 439 |

**Test:** Changes a dependency atom, then reads the async atom (which automatically recomputes).

### Async Chain (2 Levels)

**Performance:**

```
ü•á   Jotai              ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà       438.56 ops/sec
```

| Rank | Library | Ops/sec | Variance | Mean | p99 | Samples |
|------|---------|---------|----------|------|-----|----------|
| ü•á | **Jotai** | 438.56 | ¬±1.41% | 2.2802ms | 2.3948ms | 220 |

**Test:** Multi-level async dependencies. When base changes, all levels automatically recompute.

### Complex Async Object

**Performance:**

```
ü•á   Jotai              ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà       876.53 ops/sec
```

| Rank | Library | Ops/sec | Variance | Mean | p99 | Samples |
|------|---------|---------|----------|------|-----|----------|
| ü•á | **Jotai** | 876.53 | ¬±1.42% | 1.1409ms | 1.2210ms | 439 |

**Test:** Async computation depending on complex object structure.

### Concurrent Async (3 Atoms)

**Performance:**

```
ü•á   Jotai              ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà       857.28 ops/sec
```

| Rank | Library | Ops/sec | Variance | Mean | p99 | Samples |
|------|---------|---------|----------|------|-----|----------|
| ü•á | **Jotai** | 857.28 | ¬±1.12% | 1.1665ms | 1.2522ms | 429 |

**Test:** 3 async atoms sharing same dependency, computed concurrently.

---

## How to Run

```bash
# Run reactive async benchmarks
npm run benchmark:async

# Or run directly with vitest
npx vitest bench groups/async/async-state.bench.ts
```

## Technical Details

**What we're testing:**

- **Dependency Tracking**: Async atoms automatically track their dependencies
- **Invalidation**: When dependencies change, async results are invalidated
- **Lazy Recomputation**: Async computations re-run on next read (not eagerly)
- **Chaining**: Multi-level async dependencies work correctly
- **Concurrency**: Multiple async atoms can compute in parallel

**Why this matters:**

In modern apps, you often have:
- Data fetched from APIs that depends on user selections
- Derived data that requires async processing
- Complex async workflows with multiple steps

Reactive async makes this trivial - change a filter, all dependent async queries automatically refresh. Without it, you need complex manual coordination.

---

*Last updated: 2025-11-10T18:55:00.000Z*
*Generated by: group-readme-generator.cjs*

üîó [‚Üê Back to State Management Overview](../../README.md)
